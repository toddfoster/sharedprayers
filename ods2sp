#!/usr/bin/env python3
import calendar
import json
from pathlib import Path
import os
import argparse
from dateutil.easter import *
from dateutil.relativedelta import *
from datetime import *
from pyexcel_ods3 import get_data

"""ods2sp : ods to SharedPrayers
Produce liturgies for a particular year based on the liturgical
calendar from the Book of Common Prayer (1979) for Sundays and
Major Feasts, using a libreoffce Calc file (.ods) for templates.

Required data sources are:
 - calcdates.json: info on how to calculate the calendar dates
   of Sundays & major feasts
 - bcpcollects.json: source of proper titles for Sundays/feasts
 - templates file (ods): source of templates

Usage
  ods2sp [year] [flags...]
  year = numeric year (e.g., 2022 will generate liturgies from
         Advent 1 (28 Nov 2021) through Proper 29/CTK (20 Nov 2022).
         Defaults to current year according to the liturgical
         calendar.

Flags
 - --dry-run : don't write anything to disk
 - --past -p : generate liturgies even for dates already past
 - --templates -t dir : .ods file with templates
 - --output -o dir : directory for output
 - --day -d day : code for liturgical day to generate
 - --lectionary: generate a 'lectionary' of lessons on a single page
 - --help -h : command-line options
 - --usage : more information

Templates
 Templates are contained in a LibreOffice Calc file. Template will
 be chosen from a sheet named after the desired year. In that sheet,
 a row with the liturgical day code in the fifth column will be
 selected as the chosen template. It is suggested a "default" row
 be provided in case the desired day code is not found. Columns 1-4
 are ignored. Columns 6 and 7 have special meaning, being used to
 populate the "rite:" and "bcppage:" fields of the page headers,
 respectively. Columns that begin with "#" are passed through without
 changes. Columns that begin with ";" are ignored as comments.
 Certain codes will take the next column as a hymn specification
 (or blank).

The liturgies output, as origianlly implemented, are used to
populate the website https://www.sharedprayers.net using
the static website generator hugo (https://www.gohugo.io).
"""

copyright = """Copyright 2022 Todd Foster

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

# Important data files
# https://github.com/toddfoster/sharedprayers/tree/master/data
CALCDATESFILE = 'data/calcdates.json'
COLLECTSFILE = 'data/bcpcollects.json'
TEMPLATESFILE = 'liturgyplans.ods'

# Default directories
TEMPLATESDIR = "liturgytemplates"
OUTPUTDIR = "content/archive"

####################################################
####################################################
"""
argparse:
https://docs.python.org/3/library/argparse.html#module-argparse
https://docs.python.org/3/howto/argparse.html
"""
parser = argparse.ArgumentParser()
parser.add_argument('year',
                    help='Year to generate (beginning from Advent 1 of previous calendar year).')
parser.add_argument('--dry-run', action="store_true", help="don't write anything to disk")
parser.add_argument('-p', '--past', action="store_true",
                    help="generate liturgies even for dates already past")
parser.add_argument('-d', '--day', type=str,
                    help='specific day code to generate (e.g., first-sunday-of-advent)')
parser.add_argument('--usage', action="store_true", help="more usage information")
parser.add_argument('--copyright', action="store_true", help="show copyright info")
parser.add_argument('--templates', type=str, help='templates file')
parser.add_argument('--output', type=str, help='output directory')
parser.add_argument('--debug', action="store_true", help="show debugging info")
parser.add_argument('--lectionary', action="store_true", help="generate lessons for the whole year")

args = parser.parse_args()

if args.usage:
    print(__doc__)
    sys.exit(0)

if args.copyright:
    print(copyright)
    sys.exit(0)

skip_past_dates = not args.past
dry_run = args.dry_run
only_day = args.day
only_lectionary = args.lectionary
if args.templates:
    TEMPLATESDIR = args.templates
if args.output:
    OUTPUTDIR = args.output
year = args.year
DEBUG = args.debug

####################################################
####################################################

calcdates = []
with open(CALCDATESFILE, "r", encoding='utf-8') as f:
    data = f.read()
    calcdates = json.loads(data)

collects = []
with open(COLLECTSFILE, "r", encoding='utf-8') as f:
    data = f.read()
    collects = json.loads(data)

#TODO: check for successful load or throw error
templates = get_data(TEMPLATESFILE)
COL_CODE = 4
COL_RITE = COL_CODE + 1
COL_BCPP = COL_RITE + 1
COL_BEGN = COL_BCPP + 1

def straight_quotes(text):
    single_open  = '\u2018'
    single_close = '\u2019'
    double_open  = '\u201C'
    double_close = '\u201D'
    text = text.replace(single_open,  "'")
    text = text.replace(single_close, "'")
    text = text.replace(double_open,  '"')
    text = text.replace(double_close, '"')
    return text

def sundayafterchristmas(year):
    return date(year,12,26) + relativedelta(weekday=calendar.SUNDAY)

def sundayafterepiphany(year):
    return date(year,1,7) + relativedelta(weekday=calendar.SUNDAY)

def getrecord(data, day):
    for i in data:
        if i['day'] == day:
            return i

def liturgydate(day, year):
    """
    Calculate the calendar date for a liturgy in a liturgical year.

    Liturgical year begins on Advent 1 (fourth Sunday before
    Christmas). So liturgydate('first-sunday-of-advent', 2022)
    returns "2021-11-28".
    """
    year = int(year)

    # special case: thanksgiving-day on fourth Thursday in November
    if day == 'thanksgiving-day':
        return date(year,11,22) + relativedelta(weekday=calendar.THURSDAY)

    calculator = getrecord(calcdates, day)
    if not calculator:
        raise Exception ("Calculation data for day " + day + " not found.")
    method = calculator['relative']
    value = calculator['value']

    # methods = ["xmas-last", "date", "eiphany1", "easter", "xmas-next"]
    if method == 'xmas-last':
        return sundayafterchristmas(year-1) + relativedelta(days=int(value))

    if method == 'xmas-next':
        return sundayafterchristmas(year) + relativedelta(days=int(value))

    if method == 'epiphany1':
        return sundayafterepiphany(year) + relativedelta(days=int(value))

    if method == 'easter':
        return easter(year) + relativedelta(days=int(value))

    if method == 'date':
        when = date.fromisoformat(value)
        when = date(year, when.month, when.day)
        # correct for static dates that occur between advent 1 & turn of year
        if when > liturgydate('first-sunday-of-advent', year+1):
            when = date(year-1, when.month, when.day)
        return when

    raise Exception("Invalid method encountered: " + method)

def lectionarytitle(day, year):
    collect = getrecord(collects, day)
    if not collect:
        raise Exception ("Title or day " + day + " not found.")
    return collect['title']

def lectionaryyear(year):
    # Working backwards, 1900 would be year a!
    year = int(year)
    if year < 1900:
        raise Exception ("Invalid year " + str(year) + ": only 1900 and later are supported.")
    year = (year - 1900) % 3
    if year == 0:
        return 'a'
    if year == 1:
        return 'b'
    return 'c'

def choosetemplate(day, year):
    sheet = templates[str(year)]
    for row in sheet:
        if row[COL_CODE]==day:
            return row
    # Didn't find it! Try default
    if day != "default":
        return choosetemplate("default", year)
    # else give up
    return []

def generateliturgy(day, year):
    template = choosetemplate(day, year)
    if DEBUG: print ("DEBUG: chose template " + str(template))

    result = "---\n"
    result += 'title: "' + lectionarytitle(day, year) + '"\n'
    result += "date: " + str(liturgydate(day, year)) + "\n"
    result += "lectionaryyear: " + lectionaryyear(year) + "\n"
    result += "proper: " + day + "\n"

    rite = template[COL_RITE]
    if rite:
        result += "rite: " + rite + "\n"
    bcpp = template[COL_BCPP]
    if bcpp:
        result += "bcppage: " + bcpp + "\n"
    result += "---\n"

    # noSecondReading = ["eastervigil", "eastermonday", "eastertuesday",
    # "easterwednesday", "easterthursday", "easterfriday", "eastersaturday"]

    closed_codes = ["lesson"]
    hymn_optional_codes = ["he/entrance", "he/sequence", "he/offertory", "he/communion"]
    maybe_hymn = ""

    for col in range(COL_BCPP + 1, len(template)):
        entry = straight_quotes(template[col])
        if maybe_hymn:
            if DEBUG: print("Found maybe hymn: " + maybe_hymn + "(" + entry + ")")
            if entry:
                entry = maybe_hymn + ' "' + entry + '"'
            else:
                entry = maybe_hymn
            maybe_hymn = "found"

        # Check for empty cell
        if not entry:
            continue

        # Check for comment (";"): skip column
        if entry.startswith(";"):
            continue

        # Check for heading ("#"): print column as-is
        if entry.startswith("#"):
            result += "\n" + entry + "\n"
            continue

        # Check whether to look for a hymn in the next column
        if maybe_hymn != "found":
            for code in hymn_optional_codes:
                if code in entry:
                    maybe_hymn = entry
        if maybe_hymn and maybe_hymn != "found":
            continue

        # Add entry with or with a closer
        needs_closer = False
        for code in closed_codes:
            needs_closer = needs_closer or code in entry
        needs_closer = needs_closer and not entry.endswith(" /")
        if needs_closer:
            result += '{{% ' + entry + " /%}}\n"
        else:
            result += '{{% ' + entry + " %}}\n"
        maybe_hymn = ""
    return result

def shortcode(x):
    if x == "":
        return ""
    return '{{{{% {0} %}}}}\n'.format(x.strip())

def shortcode_closed(x):
    return shortcode(x).replace(" %}}", " /%}}")



def lessonstarget():
    return OUTPUTDIR + "/" + str(year) + "/lectionary.md"

def generatelessons(day, year):
    result = "##### pb\n"
    date = liturgydate(day, year)
    result += "## " + lectionarytitle(day, year) + ' - ' + date.strftime("%d %B %Y") + "\n"
    result += '{{% lesson "first" "' + day + '" /%}}\n'
    result += '{{% he/psalm/responsively "' + day + '" /%}}\n'
    result += '{{% lesson "second" "' + day + '" /%}}\n'
    result += '{{% lesson "gospel" "' + day + '" /%}}\n'
    result += "\n"
    return result

def writeliturgy(target, day, when, year):
    if only_day and only_day != day:
      return

    if dry_run:
      print ("DRY RUN: Not writing liturgy for " + day + ": " + str(when))
      return

    if only_lectionary:
        print ("Writing lessons for " + day + ": " + str(when))
        lessons = generatelessons(day, year)
        with open (lessonstarget(), "a") as t:
            t.write(lessons)
        return

    print ("Writing liturgy for " + day + ": " + str(when))
    liturgy = generateliturgy(day, year)
    with open (target + "/" + day + ".md", "w") as t:
      t.write(liturgy)
      t.write("\n")


def majorliturgies(year):
  """
  Generate liturgies for Sundays and major feasts.
  """
  target = OUTPUTDIR + "/" + str(year)
  if not dry_run:
    os.makedirs(target, exist_ok=True)

  year = int(year)

  for d in calcdates:
    dday = d['day']
    ddate = liturgydate(dday, year)

    # skip past dates?
    if skip_past_dates:
      if ddate < date.today():
        continue

    # skip second-sunday-after-christmas if it occurs after the-epiphany
    if dday == 'second-sunday-after-christmas':
      if ddate > date(year,1,6):
        continue

    # skip epiphanies that happen on or after last-sunday-after-the-epiphany
    # exploiting a fortuitous difference to not skip last-sunday-after-THE-epiphany
    if dday.find('after-epiphany') >= 0:
      if ddate >= liturgydate('last-sunday-after-the-epiphany', year):
        continue

    # skip propers that happen on or before trinity-sunday
    if dday.find('proper') >= 0:
      if ddate <=  liturgydate('trinity-sunday', year):
        continue

    writeliturgy(target, dday, ddate, year)

  # Add thanksgiving-day, which is not included in calcdates.json
  thanksgivingdate = liturgydate('thanksgiving-day', year)
  if thanksgivingdate > date.today() or not skip_past_dates:
    writeliturgy(target, 'thanksgiving-day', thanksgivingdate, year)

def lectionary(year):
    """
    Generate lectionary (lessons for each liturgy) for Sundays and major feasts.
    """

    return

if only_lectionary and not dry_run:
    print ("Writing header for lessons for " + str(year))
    with open (lessonstarget(), "w") as t:
        t.write("---\n")
        t.write("title: Lectionary (" + str(year) + ")\n")
        t.write("date: " + str(liturgydate('first-sunday-of-advent', year)) + "\n")
        t.write("lectionaryyear: " + lectionaryyear(year) + "\n")
        t.write("---\n")

majorliturgies(year)
